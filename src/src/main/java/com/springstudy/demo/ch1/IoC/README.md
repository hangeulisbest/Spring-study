## IoC (제어의 역전)
####1. 프레임워크와 라이브러리 차이?
```text
라이브러리를 사용하는 사용하는 어플리케이션 코드는 애플리케이션 흐름을 직접 제어한다.
단지 동작하는 중에 필요한 기능이 있을 때 능동적으로 라이브러리를 사용할 뿐이다. 반면에 프레임워크는 
거꾸로 애플리케이션 코드가 프레임워크에 의해 사용된다. 프레임워크에는 분명한 제어의 역전의 개념이 적용되어 있어야한다.
애플리케이션 코드는 프레임워크가 짜놓은 틀에서 수동적으로 동작해야 한다.

```
####2. 빈(Bean) 이란?
```text
스프링에서는 스프링이 제어권을 가지고 직접 만들고 관계를 부여하는 오브젝트를 빈이라고 한다.
스프링 컨테이너가 생성과 관계설정, 사용 등을 제어해주는 제어의 역전이 적용된 오브젝트를 말한다.
```

####3. Bean Factory
```text
스프링에서는 빈의 생성과 관계설정과 같은 제어를 담당하는 IoC 오브젝트를 빈팩토리라고 부른다.
빈 팩토리 보다는 이를 좀더 확장한 Application Context를 주로 사용한다.
Application Context는 어플리케이션 전반에 걸쳐 모든 구성요소의 제어 작업을 담당하는 IoC엔진이라는
의미가 더 부각된다.
```

####4. @Configuration
```text
@Configuration은 어플리케이션 컨텍스트가 활용하는 IoC 설정정보다.
@Configuration을 통해 UserDao를 ApplicationContext에 등록해두면 
클라이언트가 userDao를 요청할때 ApplicationContext에서 getBean()을 통해
빈목록에서 userDao()를 실행하여 UserDao를 반환해준다.
```

####5. ApplicationContext
```text
Bean Factory를 확장한 IoC컨테이너이다. 빈을 등록하고 관리하는 기본적인 기능은 빈 팩토리와 동일하다.
여기에 스프링이 제공하는 각종 부가 서비스를 추가로 제공한다.
빈 팩토리를 부를 때는 주로 빈의 생성과 제어의 관점에서 이야기하는 것이고,
애플리케이션 컨텍스트라고 할때는 스프링이 제공하는 애플리케이션 지원기능을 모두 포함해서 이야기한다.
ApplicationContext라고 적으면 애플리케이션 컨텍스트가 구현해야하는 기본 인터페이스를 가리키는 것이기도 하다.
```

####6. ApplicationContext 장점?
```text
1. 클라이언트는 구체적인 팩토리 클래스를 알 필요가 없다.

애플리케이션이 발전하면 DaoFactory 처럼 IoC를 적용한 오브젝트도 계속 추가된다.
필요할 때 마다 펙토리오브젝트를 찾아야하는 번거러움이 있다. 하지만 ApplicationContext를 
사용하면 일관된 방식으로 원하는 오브젝트를 가져올 수 있다.

2. 종합 IoC 서비스를 제공해준다.

애플리케이션 컨텍스트의 역할은 단지 오브젝트 생성과 다른 오브젝트와의 관계설정만이 전부가 아니다.
오브젝트가 만들어지는 방식,시점과 전략을 다르게 가져갈 수도 있고, 이에 부가적으로 자동생성,
오브젝트에 대한 후처리,정보의 조합,설정 방식의 다변화 등 오브젝트를 효과적으로 활용할 수 있는
다양한 기능을 제공한다.

3. 빈을 검색하는 다양한 방법을 제공한다.

```

####7. DaoFactory = 컴포넌트의 설계도 (IoC)
```text
DaoFactory를 통해 얻을 수 있는 장점은 UserDao가 어떤 DB연결을 쓰던지 컴포넌트의 로직은
변하지 않는다. 컴포넌트와 설계도 역할을 하는 팩토리를 구분함으로써 책임과 관심을 분리한다.
```

####8.  고전적인 싱글톤 패턴의 한계
```java
public class UserDao{  
    private static UserDao INSTANCE;

    private UserDao(ConnectionMaker connectionMaker){
        this.connectionMaker = connectionMaker;
    }
    
    public static synchronized UserDao getInstance(){
        if(INSTANCE == null) INSTANCE = new UserDao(new DConnectionMaker());
        return INSTANCE;
    }
}
```
```text
고전적인 싱글톤의 한계는 다음과 같다.
1. private 생성자를 갖고 있기 때문에 상속할 수 없다.
- 다른 생성자가 없다면 상속이 불가능 한데 이는 객체지향적인 설계의 장점을 적용하기가 어렵다.
또한 상속과 다형성 같은 객체지향의 특징이 적용되지 않는 스태틱필드와 메소드를 사용하는 것도 역시 
동일한 문제이다.

2. 싱글톤은 테스트하기 어렵다.
- 싱글톤은 만들어지는 방식이 제한적이기 때문에 목 오브젝트등으로 대체하기가 힘들다.
또한 초기화 과정에서 생성자등을 통해 사용할 오브젝트를 다이내믹하게 주입하기도 힘들다.

3. 싱글톤의 사용은 전역상태를 만들 수 있기 때문에 바람직하지 못하다.
- 싱글톤을 사용하는 클라이언트가 정해져있지 않다. 스태틱 메소드를 이용해 언제든지 접근할수 있으므로
애플리케이션 어디서든지 사용될 수 있고 자연스럽게 전역상태로 사용되기 쉽다. 
```
####9. 싱글톤 레지스트리
```
스프링 컨테이너는 싱글톤을 생성하고 관리하고 공급하는 싱글톤 관리 컨테이너다.
싱글톤 레지스트리는 스태틱메소드와 private생성자를 사용해야 하는 비정상적인 클래스가 아니라
평범한 자바클래스를 싱글톤으로 활용하게 해준다는 점이다. 평범한 자바클래스라도
IoC컨테이너를 사용해서 생성과 관계설정,사용 등에 대한 제어권을 컨테이너에게 넘기면
손쉽게 싱글톤 방식으로 만들어져 관리되게 할 수 있다.
```